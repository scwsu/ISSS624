[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data in using appropriate R Packages."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#overview",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#overview",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data in using appropriate R Packages."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#getting-started",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#getting-started",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "2. Getting Started",
    "text": "2. Getting Started\nThe following code chunk installs and loads sf and tidyverse packages into R environment.\n\n\n\n\n\n\nNote\n\n\n\nsf package is used for importing, managing, and processing geospatial data.\n\n\n\npacman::p_load(sf, tidyverse)\n\nThe data sets used are:\n\nMaster Plan 2014 Subzone Boundary (Web) from data.gov.sg\nPre-Schools Location from data.gov.sg\nCycling Path from LTADataMall\nLatest version of Singapore Airbnb listing data from Inside Airbnb"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#importing-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#importing-geospatial-data",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "3. Importing Geospatial Data",
    "text": "3. Importing Geospatial Data\n\n3.1. Importing Polygon Feature Data\nThe following code chunk uses `st_read()` function from the sf package to import `MP14_SUBZONE_WEB_PL` shapefile into R as polygon feature data frame.\n\n\n\n\n\n\nNote\n\n\n\nWhen loading geospatial data in shapefile format, two arguments are utilized: firstly, dsn to specify the data path, and secondly, layer to indicate the name of the shapefile. It’s not necessary to include file extensions such as .shp, .dbf, .prj, or .shx.\n\n\n\nmpsz &lt;- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\scwsu\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nThe `mpsz` simple feature data frame consists of 323 multipolygon features and includes 15 fields. It is defined using the svy21 projected coordinate system.\n\n\n\n\n\n\nNote\n\n\n\nThe svy21, also known as the Singapore svy21 Projected Coordinate System, is a coordinate system employed by Singapore. It uses the Transverse Mercator projection, mapping geographical coordinates that reference the WGS 84 ellipsoid.\nThe bounding box of this system displays the extent of the data in both the x and y dimensions.\n\n\n\n\n3.2. Importing Polyline Feature Data\nThe following code chunk uses `st_read()` function from the sf package to import `CyclingPath` shapefile into R as line feature data frame.\n\ncyclingpath &lt;- st_read(dsn = \"data/geospatial\",\n                       layer = \"CyclingPathGazette\")\n\nReading layer `CyclingPathGazette' from data source \n  `D:\\scwsu\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2558 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nThe `cyclingpath` linestring feature data frame contains a total of 2558 features and comprises 2 fields. It is also defined within the svy21 projected coordinate system.\n\n\n3.3. Importing GIS Data\nThe following code chunk uses `st_read()` function from the sf package to import `PreSchoolsLocation` into R.\n\n\n\n\n\n\nNote\n\n\n\nThe complete path and kml file extension must be provided in kml format.\n\n\n\npreschool &lt;- st_read(\"data/geospatial/PreSchoolsLocation.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `D:\\scwsu\\ISSS624\\Hands-on_Ex1\\data\\geospatial\\PreSchoolsLocation.kml' \n  using driver `KML'\nSimple feature collection with 2290 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nThe `preschool` point feature data frame contains a combined total of 2290 features and comprises 2 fields. Notably, unlike the two preceding simple feature data frames, `preschool` employs the wgs84 geographic coordinate system.\n\n\n\n\n\n\nNote\n\n\n\nwgs84 represents the latest version of the World Geodetic System (WGS), a global standard utilized in fields like cartography, geodesy, and satellite navigation, including GPS. It is a geographic coordinate system that determines locations on Earth using a three-dimensional spherical surface model."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#checking-the-content-of-a-simple-feature-data-frame",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#checking-the-content-of-a-simple-feature-data-frame",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "4. Checking the Content of A Simple Feature Data Frame",
    "text": "4. Checking the Content of A Simple Feature Data Frame\nThe column in the simple feature (sf) data frame that holds the geometries is structured as a list with a class of sfc. There are two methods to inspect the data within it:\n\nObtain the geometry list-column by using either `mpsz$geom` or `mpsz[[i]]`.\nUtilize `st_geometry` to present details about the feature class, including information about the geometry type, the geographic extent of the features, and the coordinate system used in the data.\n\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nA peek into the data using the `glimpse` function from the dplyr package unveils relevant attribute details, including the data type of each field.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO &lt;int&gt; 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  &lt;chr&gt; \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  &lt;chr&gt; \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     &lt;chr&gt; \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N &lt;chr&gt; \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C &lt;chr&gt; \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   &lt;chr&gt; \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   &lt;chr&gt; \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    &lt;chr&gt; \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D &lt;date&gt; 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     &lt;dbl&gt; 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     &lt;dbl&gt; 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng &lt;dbl&gt; 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area &lt;dbl&gt; 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nUsing `head()` in the base R provides a comprehensive view of a feature object`s information.\n\n\n\n\n\n\nNote\n\n\n\nAdjust the “n” argument to modify the number of observations to a reasonable value.\n\n\n\nhead(mpsz, n=5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#plotting-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#plotting-geospatial-data",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "5. Plotting Geospatial Data",
    "text": "5. Plotting Geospatial Data\nIn the realm of geospatial data analytics, merely examining feature details is inadequate. To visualize geospatial features, you can employ the `plot()` function from R Graphic.\n\n\n\n\n\n\nNote\n\n\n\nBy default, a sf object generates a multiplot. The subsequent plot illustrates the initial 9 of 15 attributes. To adjust the quantity of attributes displayed in the plot, modify the `max.plot` parameter to a desired value.\n\n\n\nplot(mpsz)\n\n\n\n\nTo plot the geometric data exclusively , apply `st_geometry` to the data frame prior to initiating the plot.\n\nplot(st_geometry(mpsz))\n\n\n\n\nA plot focusing on a particular attribute of the sf object can also be created.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\nplot(mpsz[\"SUBZONE_N\"])\n\n\n\nplot(mpsz[\"REGION_N\"])\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n`plot()` is meant for plotting the geospatial object for a quick look. For high cartographic quality plot, other R package such as tmap should be used."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#map-projection",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#map-projection",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "6. Map Projection",
    "text": "6. Map Projection\nMap projection is a critical characteristic of geospatial data. To carry out geoprocessing tasks with two different geospatial datasets, they need to be aligned within the same coordinate system.\nThe process of transforming a simple feature data frame from one coordinate system to another is technically referred to as projection transformation.\n\n6.1. Assigning EPSG code to a simple feature data frame\nTypical problems that may arise while importing geospatial data into R include:\n\nThe absence of a coordinate system for the original data, which can occur if, for instance, the .proj file is missing for an ESRI shapefile.\nIncorrect assignment of a coordinate system during the import procedure.\n\nTo examine the coordinate system of the `mpsz` simple feature data frame, employ the `st_crs()` function from the sf package.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nThe printout above shows the EPSG as 9001. Nonetheless, the `mpsz` data frame actually utilizes the svy21 projection, for which the appropriate EPSG code is 3414. To apply the right EPSG code to the `mpsz` data frame, utilize the `st_set_crs()` function from the sf package.\n\nmpsz3414 &lt;- st_set_crs(mpsz, 3414)\n\nThe EPSG code indicated is now 3414.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n6.2 Transforming the projection of preschool from wgs84 to svy21\nIn geospatial analytics, it is a common practice to convert data from a Geographic Coordinate System (GCS) to a Projected Coordinate System (PCS). GCS may not be suitable for analyses that require accurate distance or area measurements, as the length of one degree varies significantly with latitude — it`s shorter near the poles and longer near the equator. On the other hand, PCS offers uniform measurements of length and area across different locations. The `st_transform()` function in the sf package is used for mathematically reprojecting data frames from one coordinate system to another.\nGiven that the `preschool` data frame is currently in the wgs84 coordinate system, it can be effectively transformed to the svy21 projected coordinate system, which has the coordinate reference system (CRS) code of 3414.\n\npreschool3414 &lt;- st_transform(preschool, \n                              crs = 3414)\n\n`preschool3414` data frame is now in svy21 projected coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 2290 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11810.03 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe success of the transformation can be confirmed by examining the x and y extents of the data as shown in the Bounding Box. Most geographic coordinate systems operate within a decimal degree range of 0-360. However, after the projection transformation of the `preschool3414` data frame, the x and y extents of the data will be significantly greater than 360, indicating the change to a projected coordinate system."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#importing-and-converting-an-aspatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#importing-and-converting-an-aspatial-data",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "7. Importing and Converting an Aspatial Data",
    "text": "7. Importing and Converting an Aspatial Data\nTypically, one might encounter aspatial data that includes two separate fields representing the x- and y-coordinates of the data points. Such aspatial data can be transformed from a tibble data frame into a simple feature data frame, enabling more comprehensive geospatial analysis.\n\n7.1. Importing Aspatial Data as Tibble Data Frame\nThe following code chunk uses `read_csv()` function of readr package to import the `listings.csv` data from Airbnb. The output R object is a tibble data frame called `listings`.\n\nlistings &lt;- read_csv(\"data/aspatial/listings.csv\")\n\nThe following code chunk uses `list()` of Base R instead of `glimpse()` to examine if the data file has been imported correctly.\n\nlist(listings) \n\n[[1]]\n# A tibble: 3,483 × 75\n       id listing_url            scrape_id last_scraped source name  description\n    &lt;dbl&gt; &lt;chr&gt;                      &lt;dbl&gt; &lt;date&gt;       &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;      \n 1  71609 https://www.airbnb.co…   2.02e13 2023-09-23   previ… Vill… For 3 room…\n 2  71896 https://www.airbnb.co…   2.02e13 2023-09-23   previ… Home… &lt;b&gt;The spa…\n 3  71903 https://www.airbnb.co…   2.02e13 2023-09-23   previ… Home… Like your …\n 4 275343 https://www.airbnb.co…   2.02e13 2023-09-23   city … Rent… **IMPORTAN…\n 5 275344 https://www.airbnb.co…   2.02e13 2023-09-23   city … Rent… Lovely hom…\n 6 289234 https://www.airbnb.co…   2.02e13 2023-09-23   previ… Home… This whole…\n 7 294281 https://www.airbnb.co…   2.02e13 2023-09-23   city … Rent… I have 3 b…\n 8 324945 https://www.airbnb.co…   2.02e13 2023-09-23   city … Rent… **IMPORTAN…\n 9 330095 https://www.airbnb.co…   2.02e13 2023-09-23   city … Rent… **IMPORTAN…\n10 369141 https://www.airbnb.co…   2.02e13 2023-09-23   city … Plac… A room in …\n# ℹ 3,473 more rows\n# ℹ 68 more variables: neighborhood_overview &lt;chr&gt;, picture_url &lt;chr&gt;,\n#   host_id &lt;dbl&gt;, host_url &lt;chr&gt;, host_name &lt;chr&gt;, host_since &lt;date&gt;,\n#   host_location &lt;chr&gt;, host_about &lt;chr&gt;, host_response_time &lt;chr&gt;,\n#   host_response_rate &lt;chr&gt;, host_acceptance_rate &lt;chr&gt;,\n#   host_is_superhost &lt;lgl&gt;, host_thumbnail_url &lt;chr&gt;, host_picture_url &lt;chr&gt;,\n#   host_neighbourhood &lt;chr&gt;, host_listings_count &lt;dbl&gt;, …\n\n\nThe `listing` tibble data frame consists of 3483 rows and 18 columns. For the next step, `latitude` and `longitude` columns will be used.\n\n\n\n\n\n\nNote\n\n\n\n`latitude` and `longitude` columns are in decimal degree format, suggesting that the data could be in wgs84 geographic coordinate system.\n\n\n\n\n7.2. Converting Tibble Data Frame to Simple Feature Data Frame\nThe following code chunk converts `listing` data frame into a simple feature data frame using `st_as_sf()` of sf package.\n\nlistings_sf &lt;- st_as_sf(listings,\n                        coords = c(\"longitude\", \"latitude\"),\n                        crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\n\n\n\n\n\n\nNote\n\n\n\nThe `coords` argument necessitates specifying the column name for the x-coordinates first, followed by the column name for the y-coordinates.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe `crs` argument needs the coordinate system to be defined in the EPSG format. For instance, EPSG 4326 corresponds to the wgs84 geographic coordinate system, while EPSG 3414 represents the svy21 projected coordinate system. For EPSG codes of other countries, you can consult the website epsg.io.\n\n\n\nglimpse(listings_sf)\n\nRows: 3,483\nColumns: 74\n$ id                                           &lt;dbl&gt; 71609, 71896, 71903, 2753…\n$ listing_url                                  &lt;chr&gt; \"https://www.airbnb.com/r…\n$ scrape_id                                    &lt;dbl&gt; 2.023092e+13, 2.023092e+1…\n$ last_scraped                                 &lt;date&gt; 2023-09-23, 2023-09-23, …\n$ source                                       &lt;chr&gt; \"previous scrape\", \"previ…\n$ name                                         &lt;chr&gt; \"Villa in Singapore · ★4.…\n$ description                                  &lt;chr&gt; \"For 3 rooms.Book room 1&…\n$ neighborhood_overview                        &lt;chr&gt; NA, NA, \"Quiet and view o…\n$ picture_url                                  &lt;chr&gt; \"https://a0.muscache.com/…\n$ host_id                                      &lt;dbl&gt; 367042, 367042, 367042, 1…\n$ host_url                                     &lt;chr&gt; \"https://www.airbnb.com/u…\n$ host_name                                    &lt;chr&gt; \"Belinda\", \"Belinda\", \"Be…\n$ host_since                                   &lt;date&gt; 2011-01-29, 2011-01-29, …\n$ host_location                                &lt;chr&gt; \"Singapore\", \"Singapore\",…\n$ host_about                                   &lt;chr&gt; \"Hi My name is Belinda -H…\n$ host_response_time                           &lt;chr&gt; \"within a few hours\", \"wi…\n$ host_response_rate                           &lt;chr&gt; \"100%\", \"100%\", \"100%\", \"…\n$ host_acceptance_rate                         &lt;chr&gt; \"100%\", \"100%\", \"100%\", \"…\n$ host_is_superhost                            &lt;lgl&gt; FALSE, FALSE, FALSE, FALS…\n$ host_thumbnail_url                           &lt;chr&gt; \"https://a0.muscache.com/…\n$ host_picture_url                             &lt;chr&gt; \"https://a0.muscache.com/…\n$ host_neighbourhood                           &lt;chr&gt; \"Tampines\", \"Tampines\", \"…\n$ host_listings_count                          &lt;dbl&gt; 5, 5, 5, 52, 52, 5, 7, 52…\n$ host_total_listings_count                    &lt;dbl&gt; 15, 15, 15, 65, 65, 15, 8…\n$ host_verifications                           &lt;chr&gt; \"['email', 'phone']\", \"['…\n$ host_has_profile_pic                         &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, T…\n$ host_identity_verified                       &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, T…\n$ neighbourhood                                &lt;chr&gt; NA, NA, \"Singapore, Singa…\n$ neighbourhood_cleansed                       &lt;chr&gt; \"Tampines\", \"Tampines\", \"…\n$ neighbourhood_group_cleansed                 &lt;chr&gt; \"East Region\", \"East Regi…\n$ property_type                                &lt;chr&gt; \"Private room in villa\", …\n$ room_type                                    &lt;chr&gt; \"Private room\", \"Private …\n$ accommodates                                 &lt;dbl&gt; 3, 1, 2, 1, 1, 4, 2, 1, 1…\n$ bathrooms                                    &lt;lgl&gt; NA, NA, NA, NA, NA, NA, N…\n$ bathrooms_text                               &lt;chr&gt; \"1 private bath\", \"Shared…\n$ bedrooms                                     &lt;dbl&gt; NA, NA, NA, NA, NA, 3, NA…\n$ beds                                         &lt;dbl&gt; 3, 1, 2, 1, 1, 5, 1, 1, 1…\n$ amenities                                    &lt;chr&gt; \"[\\\"Private backyard \\\\u2…\n$ price                                        &lt;chr&gt; \"$150.00\", \"$80.00\", \"$80…\n$ minimum_nights                               &lt;dbl&gt; 92, 92, 92, 60, 60, 92, 9…\n$ maximum_nights                               &lt;dbl&gt; 365, 365, 365, 999, 999, …\n$ minimum_minimum_nights                       &lt;dbl&gt; 92, 92, 92, 60, 60, 92, 9…\n$ maximum_minimum_nights                       &lt;dbl&gt; 92, 92, 92, 60, 60, 92, 9…\n$ minimum_maximum_nights                       &lt;dbl&gt; 1125, 1125, 1125, 1125, 1…\n$ maximum_maximum_nights                       &lt;dbl&gt; 1125, 1125, 1125, 1125, 1…\n$ minimum_nights_avg_ntm                       &lt;dbl&gt; 92, 92, 92, 60, 60, 92, 9…\n$ maximum_nights_avg_ntm                       &lt;dbl&gt; 1125, 1125, 1125, 1125, 1…\n$ calendar_updated                             &lt;lgl&gt; NA, NA, NA, NA, NA, NA, N…\n$ has_availability                             &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, T…\n$ availability_30                              &lt;dbl&gt; 28, 28, 28, 1, 30, 28, 30…\n$ availability_60                              &lt;dbl&gt; 58, 58, 58, 1, 60, 58, 60…\n$ availability_90                              &lt;dbl&gt; 88, 88, 88, 1, 90, 88, 90…\n$ availability_365                             &lt;dbl&gt; 89, 89, 89, 275, 274, 89,…\n$ calendar_last_scraped                        &lt;date&gt; 2023-09-23, 2023-09-23, …\n$ number_of_reviews                            &lt;dbl&gt; 20, 24, 47, 22, 17, 12, 1…\n$ number_of_reviews_ltm                        &lt;dbl&gt; 0, 0, 0, 0, 3, 0, 0, 1, 3…\n$ number_of_reviews_l30d                       &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 1…\n$ first_review                                 &lt;date&gt; 2011-12-19, 2011-07-30, …\n$ last_review                                  &lt;date&gt; 2020-01-17, 2019-10-13, …\n$ review_scores_rating                         &lt;dbl&gt; 4.44, 4.16, 4.41, 4.40, 4…\n$ review_scores_accuracy                       &lt;dbl&gt; 4.37, 4.22, 4.39, 4.16, 4…\n$ review_scores_cleanliness                    &lt;dbl&gt; 4.00, 4.09, 4.52, 4.26, 4…\n$ review_scores_checkin                        &lt;dbl&gt; 4.63, 4.43, 4.63, 4.47, 4…\n$ review_scores_communication                  &lt;dbl&gt; 4.78, 4.43, 4.64, 4.42, 4…\n$ review_scores_location                       &lt;dbl&gt; 4.26, 4.17, 4.50, 4.53, 4…\n$ review_scores_value                          &lt;dbl&gt; 4.32, 4.04, 4.36, 4.63, 4…\n$ license                                      &lt;chr&gt; NA, NA, NA, \"S0399\", \"S03…\n$ instant_bookable                             &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE…\n$ calculated_host_listings_count               &lt;dbl&gt; 5, 5, 5, 52, 52, 5, 7, 52…\n$ calculated_host_listings_count_entire_homes  &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 1, 1…\n$ calculated_host_listings_count_private_rooms &lt;dbl&gt; 5, 5, 5, 51, 51, 5, 6, 51…\n$ calculated_host_listings_count_shared_rooms  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ reviews_per_month                            &lt;dbl&gt; 0.14, 0.16, 0.31, 0.17, 0…\n$ geometry                                     &lt;POINT [m]&gt; POINT (41972.5 3639…\n\n\nThe table above presents the contents of `listings_sf`. In this data frame, a new `geometry` column has been included, and the columns for longitude and latitude have been removed."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#geoprocessing-with-sf-package",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#geoprocessing-with-sf-package",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "8. Geoprocessing with sf Package",
    "text": "8. Geoprocessing with sf Package\nIn addition to supplying tools for managing geospatial data — including import, export, projection assignment, and projection transformation — the sf package also encompasses an extensive array of geoprocessing (commonly referred to as GIS analysis) capabilities, like creating buffers and performing point-in-polygon counts.\n\n8.1. Buffering\nCreating a buffer serves to examine and assess the spatial relationships among features within a certain distance. This buffer is usually defined in units of distance, such as meters or kilometers, and delineates a designated radius or width surrounding the feature.\nConsider the `CyclingPath` dataset as a case in point:\nIf there is a proposal to enhance the existing cycling path and it`s necessary to secure a 5-meter strip of land on each side of the path, one must calculate the extent of land required for acquisition and the total area of this land.\nFor this purpose, the st_buffer() function from the sf package is employed to create 5-meter buffers along the cycling paths.\n\n\n\n\n\n\nNote\n\n\n\ndist argument takes in the numeric buffer distance to be computed.\n\n\n\n\n\n\n\n\nNote\n\n\n\nnQuadSegs argument refers to ‘the number of segments per quadrant’ and is set by default to 30 (meaning circles created by buffers are composed of 4 × 30 = 120 lines). This argument may be useful to include when the memory consumed by the output of a buffer operation is a major concern (in which case it should be reduced) or when very high precision is needed (in which case it should be increased).\n\n\n\nbuffer_cycling &lt;- st_buffer(cyclingpath, dist=5, nQuadSegs=30)\n\nSubsequently, the area within these buffers is calculated and then aggregated to determine the overall amount of land implicated.\n\nbuffer_cycling$AREA &lt;- st_area(buffer_cycling)\n\nsum(buffer_cycling$AREA)\n\n1774367 [m^2]\n\n\n\n\n8.2. Point-in-polygon Count\nThe number of points in each polygon given a set of points and a set of polygons.\nIn computational geometry, the point-in-polygon (PIP) challenge involves determining whether a point lies within, outside, or along the boundary of a polygon.\nFor instance, using the PreSchoolsLocation dataset:\nImagine a research initiative by a preschool group to analyze the spread of preschools across each Planning Subzone, aiming to ascertain the count and concentration of preschools within each subzone.\nThe st_intersects() function from the sf package is utilized to pinpoint preschools situated within each Planning Subzone. The lengths() function from Base R is then applied to tally the number of preschools within each Subzone, and the summary() function is employed to present the summary statistics for the newly computed PreSch Count field.\n\n\n\n\n\n\nNote\n\n\n\nThe functions st_intersects() and st_intersection() serve distinct purposes within spatial operations. st_intersects() yields a logical output, indicating the presence or absence of an intersection between two sets of geometries. On the other hand, st_intersection() conducts geometric operations, delivering the actual geometric intersection, as well as the difference or symmetric difference between two sets of geometries.\n\n\n\nmpsz3414$`PreSch Count`&lt;- lengths(st_intersects(mpsz3414, preschool3414))\n\nsummary(mpsz3414$\"PreSch Count\")\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    4.00    7.09   10.00   72.00 \n\n\ntop_n() of dplyr package is used to list the Planning Subzone with the highest number of pre-schools.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry PreSch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           72\n\n\nThe following code chunk uses st_area() of sf package to derive the area of each Planning Subzone.\n\nmpsz3414$Area &lt;- mpsz3414 %&gt;%\n  st_area()\n\nTo compute the density, mutate() of dplyr package is used.\n\nmpsz3414 &lt;- mpsz3414 %&gt;%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1.html#exploratory-data-analysis",
    "href": "Hands-on_Ex1/Hands-on_Ex1.html#exploratory-data-analysis",
    "title": "1A: Geospatial Data Wrangling with R",
    "section": "9. Exploratory Data Analysis",
    "text": "9. Exploratory Data Analysis\nLeveraging suitable ggplot2 functions can facilitate the construction of effective statistical graphs for exploratory data analysis (EDA).\n\n9.1. Histogram on Preschool Density\nThe distribution of `PreSch Density` is displayed using the hist() function from the R Graphics package to create a histogram.\n\nhist(mpsz3414$`PreSch Density`)\n\n\n\n\nThe following code chunk uses ggplot2 functions such as geom_histogram().\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"white\",\n                 fill=\"steelblue\") +\n  labs(title = \"Are preschools even distributed in Singapore?\",\n       subtitle= \"Most Planning Subzones have a low preschool density (&lt;10 preschools per km sq)\\nOne Planning Subzone has a preschool density of &gt;30 preschools per km sq\",\n      x = \"Preschool density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n9.2. Scatterplot between Preschool Density and Preschool Count\nThe following code chunk, a scatterplot between Preschool Density and Preschool Count is plotted by using geom_point().\n\nggplot(data=mpsz3414, \n       aes(y = `PreSch Count`, \n           x= as.numeric(`PreSch Density`)))+\n  geom_point(color=\"steelblue\") +\n  xlim(0, 40) +\n  ylim(0, 40) +\n  labs(title = \"Scatterplot of Preschool Density and Preschool Count\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Pre-school count\")"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_b.html",
    "href": "Hands-on_Ex1/Hands-on_Ex1_b.html",
    "title": "1B: Choropleth Mapping with R",
    "section": "",
    "text": "A choropleth map is a thematic map that uses shading or patterns to depict geographic areas in relation to a statistical variable, which serves as a summary of a specific geographic attribute within each area. This variable could represent various aspects, such as population or per-capita income. For instance, you can create a choropleth map to visually display the distribution of the elderly population in Singapore by utilizing the Master Plan 2014 Subzone Boundary as a reference. In the R programming language, the tmap package provides the tools needed to generate choropleth maps."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_b.html#overview",
    "href": "Hands-on_Ex1/Hands-on_Ex1_b.html#overview",
    "title": "1B: Choropleth Mapping with R",
    "section": "",
    "text": "A choropleth map is a thematic map that uses shading or patterns to depict geographic areas in relation to a statistical variable, which serves as a summary of a specific geographic attribute within each area. This variable could represent various aspects, such as population or per-capita income. For instance, you can create a choropleth map to visually display the distribution of the elderly population in Singapore by utilizing the Master Plan 2014 Subzone Boundary as a reference. In the R programming language, the tmap package provides the tools needed to generate choropleth maps."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_b.html#getting-started",
    "href": "Hands-on_Ex1/Hands-on_Ex1_b.html#getting-started",
    "title": "1B: Choropleth Mapping with R",
    "section": "2. Getting Started",
    "text": "2. Getting Started\nThe following code chunk employs the p_load() function from the pacman package to verify whether the necessary packages have been installed on the computer. If they have been installed, the packages will be loaded.\n\nsf: for the tasks of importing, managing, and processing geospatial data\ntmap: package is used for creating thematic maps\n\n\npacman::p_load(sf, tmap, tidyverse)\n\nThe data sets used are:\n\nMaster Plan 2014 Subzone Boundary (Web) from data.gov.sg\nSingapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 from Department of Statistics"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_b.html#importing-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1_b.html#importing-data",
    "title": "1B: Choropleth Mapping with R",
    "section": "3. Importing Data",
    "text": "3. Importing Data\n\n3.1. Importing Geospatial Data into R\nThe following code chunk utilizes the st_read() function from the sf package to import the MP14_SUBZONE_WEB_PL shapefile into R, creating a simple feature data frame named mpsz.\n\nmpsz &lt;- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\scwsu\\ISSS624\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\n\n\n\n\n\n\nNote\n\n\n\nReferring to the mpsz simple feature data frame will result in displaying only the initial 10 rows. This simplifies working with extensive datasets and prevents R from trying to show every row within a data frame.\n\n\n\n\n3.2. Importing Attribute Data into R\nThe following code chunk employs the read_csv() function from the readr package to load the respopagesextod2011to2020.csv file into R and store it as a R dataframe named popdata.\n\npopdata &lt;- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\n\n\n3.3. Preparing the Data\nBefore creating a thematic map, the popdata is transformed into a data table with values for the year 2020. This data table includes the following variables:\n\nYOUNG: Representing age groups from 0 to 4 up to age group 20 to 24.\nECONOMY ACTIVE: Covering age groups from 25-29 to age group 60-64.\nAGED: Encompassing age group 65 and above.\nTOTAL: Combining all age groups.\nDEPENDENCY: Calculating the ratio between the young and aged populations against the economy-active group.\n\nTo perform these data wrangling and transformation tasks, various functions are utilized, including pivot_wider() from the tidyr package, as well as mutate(), filter(), group_by(), and select() from the dplyr package.\n\npopdata2020 &lt;- popdata %&gt;%\n  filter(Time == 2020) %&gt;%\n  group_by(PA, SZ, AG) %&gt;%\n  summarise(`POP` = sum(`Pop`)) %&gt;%\n  ungroup()%&gt;%\n  pivot_wider(names_from=AG, values_from=POP) %&gt;%\n  mutate(YOUNG = rowSums(.[3:6])+rowSums(.[12])) %&gt;%\n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+rowSums(.[13:15]))%&gt;%\n  mutate(`AGED`=rowSums(.[16:21])) %&gt;%\n  mutate(`TOTAL`=rowSums(.[3:21])) %&gt;%  \n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMY ACTIVE`) %&gt;%\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n\n\n\n3.4. Joining Attribute and Geospatial Data\nBefore conducting the georelational join, an additional step is necessary to convert the values in the PA and SZ fields to uppercase. This adjustment is needed because the PA and SZ fields contain a mix of upper and lowercase characters, whereas the SUBZONE_N and PLN_AREA_N columns are entirely in uppercase.\n\npopdata2020 &lt;- popdata2020 %&gt;%\n  mutate(across(where(is.character), toupper)) %&gt;%\n  filter(`ECONOMY ACTIVE` &gt; 0)\n\nSubsequently, the left_join() function from the dplyr package is employed to merge the geographical data and attribute table using the Planning Subzone name, specifically “SUBZONE_N” and “SZ,” as the shared identifier.\n\nmpsz_pop2020 &lt;- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\n\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_b.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex1/Hands-on_Ex1_b.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "1B: Choropleth Mapping with R",
    "section": "4. Choropleth Mapping Geospatial Data Using tmap",
    "text": "4. Choropleth Mapping Geospatial Data Using tmap\nThere are two methods for creating thematic maps using the tmap package:\n\nSwiftly generating a thematic map with basic settings using qtm().\nCrafting a highly customizable thematic map by utilizing tmap elements.\n\n\n4.1. Plotting a choropleth map quickly by using qtm()\nqtm() is the most straightforward and efficient way to create a choropleth map with tmap. It offers a concise approach and provides a suitable default visualization for many scenarios. The following code snippet will generate a standard choropleth map as depicted below.\n\n\n\n\n\n\nNote\n\n\n\nWhen using tmap_mode() with the plot option, it generates a static map. To enable interactive mode, you should utilize the view option.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe fill argument is employed to associate and represent the attribute of interest on the map.\n\n\n\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNonetheless, when utilizing qtm(), it can be more challenging to precisely control the aesthetics of individual layers. To create a top-notch cartographic choropleth map, it’s advisable to employ tmap drawing elements.\n\n\n\n\n4.2. Drawing Base Map using tmap elements\nThe fundamental component of tmap consists of tm_shape() followed by one or more layer elements, such as tm_fill() and tm_polygons(). In the provided code snippet, tm_shape() is employed to specify the input data (i.e., mpsz_pop2020), and tm_polygons() is used to render the Planning Subzone polygons.\nTo create a choropleth map illustrating the spatial distribution of a specific variable based on Planning Subzones, you can assign the target variable, such as Dependency to tm_polygons().\n\n\n\n\n\n\nNote\n\n\n\nThe default method for interval binning when creating a choropleth map is pretty. tmap offers a total of ten data classification methods, which include: fixed, sd, equal, pretty (the default), quantile, kmeans, hclust, bclust, fisher, and jenks.\n\n\n\n\n\n\n\n\nNote\n\n\n\nMissing values will be shaded in grey by default.\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\n\n\n4.3. Drawing a choropleth map using tm_fill() and tm_border()\ntm_polygons() is a combined function that includes both tm_fill() and tm_borders(). tm_fill() is responsible for applying the default color scheme to shade the polygons, while tm_borders() adds the shapefile’s borders to the choropleth map.\nIn the provided code snippet, a choropleth map is created using tm_fill() alone, with the Planning Subzones being shaded based on their corresponding DEPENDENCY values.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\ntm_borders() introduces subtle light gray boundaries along the edges of the Planning Subzones.\n\n\n\n\n\n\nNote\n\n\n\nThe alpha argument is employed to specify a transparency level, ranging from 0 (completely transparent) to 1 (fully opaque). By default, the alpha value of the color (col) is utilized, which is typically set to 1. Additionally, other customizable arguments include col for border color, lwd for border line width (default is 1), and lty for border line type (default is ‘solid’).\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\n\n\n4.4. Data Classification Methods of tmap\nChoropleth maps can be categorized into two types: classified and unclassified:\n\nClassed Choropleth Maps: The purpose of classification is to take a large dataset and group its observations into distinct data ranges or classes. To define a data classification method, you can utilize the style argument within tm_fill() or tm_polygons().\nUnclassed Choropleth Maps: Similar to classified choropleth maps, unclassified maps represent geographic data, but they don’t involve an averaged statistic for each specific color.\n\nThere are numerous methods for selecting classes, and they can be based on the distribution’s nature (e.g., quantile, equal interval, natural breaks) or arbitrary criteria (e.g., fixed round numbers, census housing categories).\n\nEqual: 5 classesStandard Deviation: 5 classesQuantile: 5 classesJenks: 5 classesKMeans: 5 classesFisher: 5 classes\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe fisher style forms clusters with maximized similarity within them.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this instance, it’s worth noting that the equal data classification method results in a noticeably less balanced distribution compared to the quantile data classification method. When choosing a data classification method, it’s crucial to take into account both the distribution of the variable and the goals of the analysis as these factors play a significant role in the decision-making process.\n\n\n\nEqual: 2 classesEqual: 6 classesEqual: 10 classesEqual: 20 classesQuantile: 2 classesQuantile: 6 classesQuantile: 10 classesQuantile: 20 classes\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 2,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 10,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 20,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 2,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 10,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 20,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nExpanding the number of classes may not necessarily enhance the analysis. In the case of the equal data classification method, introducing extra classes resulted in more colors in the legend without a substantial improvement in the map’s meaning. Similarly, with the quantile data classification method, increasing the number of classes proved beneficial up to approximately n=10, but beyond that point, the added colors did not contribute significantly to the map’s value.\n\n\n\n\n4.5. Plotting Choropleth Map with Custom Breaks (Fixed Data Classification)\nIn the case of all predefined styles, the category breaks are internally calculated. However, if you wish to customize these defaults, you can explicitly specify the breakpoints using the “breaks” argument within the tm_fill() function.\n\n\n\n\n\n\nNote\n\n\n\nIn tmap, the breaks parameter encompasses both a minimum and a maximum value. Therefore, when dealing with n categories, you need to provide n+1 elements within the “breaks” option, and they should be arranged in ascending order.\n\n\nDescriptive statistics of the variable can be used to provide guidance when establishing the breakpoints.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1111  0.7147  0.7866  0.8585  0.8763 19.0000      92 \n\n\nReferring to the findings presented earlier, we established breakpoints at 0.60, 0.65, 0.70, 0.75, and 0.80. Additionally, we included minimum and maximum values, which were set at 0 and 100. Consequently, the breaks vector was defined as c(0, 0.60, 0.65, 0.70, 0.75, 0.80, 1.00).\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.65, 0.70, 0.75, 0.80, 1.00)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n4.6. Colour Scheme\ntmap provides the flexibility to use color ramps that are either custom-defined by the user or selected from a set of pre-established color ramps available in the RColorBrewer package. To modify the colors, you can assign your desired color palette to the palette argument within the tm_fill() function, as demonstrated in the following code snippet.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"jenks\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nAdd a “-” prefix to reverse the colour shading.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"jenks\",\n          palette = \"-Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n4.7. Map Layouts\nMap layout encompasses the integration of various map components into a unified whole. These map elements encompass a range of elements, such as the items to be mapped, the title, the scale bar, the compass, margins, and aspect ratios. The color configurations and data classification methods discussed in the preceding section, including the palette and breakpoints, are instrumental in influencing the map’s visual appearance. In tmap, there are several options available for adjusting the position, format, and appearance of the legend, allowing for further customization of the map’s presentation.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\ntmap offers a broad range of layout customization options that can be accessed via the tmap_style() function. The following code snippet employs the “classic” style as an example.\n\n\n\n\n\n\nNote\n\n\n\nAdditional style options include: “white,” “gray,” “natural,” “cobalt,” “col_blind,” “albatross,” “beaver,” “bw,” and “watercolor.”\n\n\n\n\n\n\n\n\nNote\n\n\n\nUse tmap_style(\"white\") to reset to the default style.\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\n\n\n\nIn addition to map styling, tmap also offers the ability to incorporate other map elements, such as a compass using tm_compass(), a scale bar using tm_scale_bar(), and grid lines using tm_grid().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Subzone boundary from Urban Redevelopment Authorithy (URA)\n             and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n4.8. Small Multiple Choropleth Maps (Facet Choropleth Maps)\nSmall multiple maps, also known as facet maps, consist of multiple maps arranged either side-by-side or vertically stacked. They offer a way to visualize how spatial relationships change in relation to another variable, such as time.\nIn tmap, you can create small multiple maps in three ways:\n\nBy assigning multiple values to at least one of the aesthetic arguments.\nBy specifying a group-by variable in tm_facets().\nBy generating multiple standalone maps and arranging them using tmap_arrange().\n\n\nBy assigning multiple values to aesthetic argumentsBy defining a group-by variable in tm_facets()By creating multiple stand-alone maps with tmap_arrange()\n\n\nSmall multiple choropleth maps can be created by defining ncols in tm_fill().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\n\n\n\n\n\nSmall multiple choropleth maps can be created by using tm_facets().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nSmall multiple choropleth maps can be created by creating multiple stand-alone maps with tmap_arrange().\n\nyoungmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\n4.9. Mapping Spatial Object Meeting a Selection Criterion\nInstead of generating small multiple choropleth maps, an alternative approach is to utilize a selection function to map spatial objects that meet specific selection criteria.\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)"
  },
  {
    "objectID": "Hands-on_Ex1.html",
    "href": "Hands-on_Ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This is the overview paragraph."
  },
  {
    "objectID": "Hands-on_Ex1.html#overview",
    "href": "Hands-on_Ex1.html#overview",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This is the overview paragraph."
  },
  {
    "objectID": "Hands-on_Ex1.html#getting-started",
    "href": "Hands-on_Ex1.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "Getting Started",
    "text": "Getting Started\nThis is the getting started paragraph."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html",
    "title": "2A: Spatial Weights and Application",
    "section": "",
    "text": "In this exercise, I learn to calculate spatial weights in R, which is an essential skill for spatial analysis. The core of my learning revolves around computing spatial weights, allowing me to understand the spatial relationships and dependencies within my data. Moreover, I gain hands-on experience in generating spatially lagged variables, which enables me to conduct in-depth analyses and interpret geospatial data with a nuanced perspective."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#overview",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#overview",
    "title": "2A: Spatial Weights and Application",
    "section": "",
    "text": "In this exercise, I learn to calculate spatial weights in R, which is an essential skill for spatial analysis. The core of my learning revolves around computing spatial weights, allowing me to understand the spatial relationships and dependencies within my data. Moreover, I gain hands-on experience in generating spatially lagged variables, which enables me to conduct in-depth analyses and interpret geospatial data with a nuanced perspective."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#getting-started",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#getting-started",
    "title": "2A: Spatial Weights and Application",
    "section": "2. Getting Started",
    "text": "2. Getting Started\nThe following code chunk installs and loads sf, readr, dplyr, spdep, tmap and purrr packages into R environment.\n\n\n\n\n\n\nNote\n\n\n\nsf package is used to import geospatial data into my working environment.\nspdep package is used to calculate spatial weights and compute spatially lagged variables.\ntmap package is used to create thematic maps in R.\ntidyverse package is used to provide a unified and consistent set of data manipulation and visualization tools for data analysis and exploration.\nknitr package is used to enable dynamic report generation and literate programming.\n\n\n\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n\nThe data sets used are:\n\nHunan county boundary layer, in ESRI shapefile format.\nHunan_2012.csv which contains selected Hunan’s local development indicators in 2012."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#getting-the-data-into-r-environment",
    "title": "2A: Spatial Weights and Application",
    "section": "3. Getting the Data Into R Environment",
    "text": "3. Getting the Data Into R Environment\n\n3.1. Importing Shapefile into R Environment\nThe following code chunk utilizes the st_read() function from the sf package to import the Hunan shapefile into R, creating a simple feature data frame named hunan.\n\nhunan &lt;- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `D:\\scwsu\\ISSS624\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n3.2. Importing CSV File into R Environment\nThe following code chunk utilizes the st_read() function from the sf package to import the Hunan_2012.csv file into R, creating a R dataframe class named hunan2012.\n\nhunan2012 &lt;- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\n\n\n3.3. Performing Relational Join\nThe following code chunks utilizes the left_join() function from the dplyr package to update the attribute table of hunan’s undefinedygons DataFrame with the attribute fields of hunan2012 dataframe.\n\nhunan &lt;- left_join(hunan,hunan2012)%&gt;%\n  select(1:4, 7, 15)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#visualising-regional-development-indicator",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#visualising-regional-development-indicator",
    "title": "2A: Spatial Weights and Application",
    "section": "3.4. Visualising Regional Development Indicator",
    "text": "3.4. Visualising Regional Development Indicator\nThe following code chunk utilizes qtm() function from the tmap package to build a basemap and choropleth map showing the distribution of GDPPC 2012.\n\n\n\n\n\n\nNote\n\n\n\nGDPPC stands for “Gross Domestic Product Per Capita”. It is a measure of a region’s economic output that accounts for its number of people. The GDP per capita is often considered an indicator of a country’s standard of living, although it is not a measure of personal income.\n\n\n\nbasemap &lt;- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#computing-contiguity-spatial-weights",
    "title": "2A: Spatial Weights and Application",
    "section": "3.5. Computing Contiguity Spatial Weights",
    "text": "3.5. Computing Contiguity Spatial Weights\nThe following code chunk utilizes the poly2nb() function form the spdep package to create contiguity weight matrices for the study area. This function constructs a list of neighbors where the regions share contiguous boundaries and also allows for a queen argument, which can be set to TRUE (default setting) or FALSE. If the argument is not explicitly set to “queen = FALSE”, the function will generate a list of first-order neighbors based on the Queen’s contiguity criterion.\n\n3.5.1. Computing (QUEEN) Contiguity Based Neighbors\nThe following code chunk is used to compute Queen contiguity weight matrix.\n\nwm_q &lt;- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThe summary report indicates that in Hunan, there are 88 area units. Among these, the most connected area unit is surrounded by 11 neighbors. On the other hand, there are two area units that have only one neighbor each.\n\n\n\n\n\n\nNote\n\n\n\nIn the analysis, the object wm_q provides a list of neighboring polygons for each polygon in our study. For instance, to view the neighbors of the first polygon in this object, a specific command is used to extract this information.\n\n\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nPolygon 1 within the Hunan SpatialPolygons DataFrame class has 5 neighbors. These neighbors are identified by their respective polygon IDs, which are numerical representations assigned to each polygon in the dataset.\nThe following code chunk is used to retrieve the country name of Polygon ID = 1.\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nThe output reveals that Polygon ID=1 is Anxiang county.\nThe following code chunk is used to reveal the country names of the five neighboring polygons.\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nThe following code chunk is used to retrieve the GDPPC of these five countries.\n\nnb1 &lt;- wm_q[[1]]\nnb1 &lt;- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nThe result above states that the GDPPC of the five nearest neighbors based on Queen’s method are 20981, 34592, 24473, 21311 and 22879 respectively.\nThe following code chunk utilizes str() function to display the complete weight matrix.\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\n3.5.2. Creating (ROOK) contiguity based neighbours\nThe following code chunk is used to compute Rook contiguity weight matrix.\n\nwm_r &lt;- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\nThe summary above reveals that in Hunan, there are a total of 88 area units. Among these, the area unit with the highest connectivity has 10 neighbors. Additionally, it is noted that there are two distinct area units that have only one neighbor each.\n\n\n3.5.3. Visualising contiguity weights\nA connectivity graph that visualizes lines connecting neighboring points is created. Since we are dealing with polygons, I first need to convert these into points. The most common approach for this is to use the centroids of the polygons. Functions from the sf package are used to calculate these centroids.\nSpecifically, I need to extract the latitude and longitude of each centroid to create a connectivity graph. This requires a bit more than just applying the st_centroid function to the us.bound sf object. To achieve this, I utilize a mapping function that applies a specific function to each element of a vector, returning a vector of equal length. My input vector is the geometry column of us.bound, and the function used is st_centroid.\nThe map_dbl function from the purrr package is employed to map st_centroid over the geometry column of us.bound. To extract the longitude values, I used double bracket notation [[]] with 1, which allowed me to get the first value (longitude) from each centroid. This method effectively provided the necessary longitude and latitude coordinates for each centroid in a separate dataframe, setting the stage for creating the connectivity graph.\n\nlongitude &lt;- purrr::map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nSimilar process is done to obtain the latitude values of the centroids, however with a crucial difference. Instead of accessing the first value of each centroid, I access the second value by using double bracket notation [[2]] in the mapping function. This approach allows me to extract the latitude, which is typically the second value in the coordinate pair of each centroid.\n\nlatitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nHaving obtained both the latitude and longitude coordinates for each centroid, I then combine these two sets of data into a single object. This is accomplished using the cbind function in R, which binds the two vectors column-wise. Applying cbind creates a single data frame where each row corresponds to a centroid, with one column for longitude and another for latitude. This consolidated data structure is essential for my subsequent analysis and for constructing the connectivity graph.\n\ncoords &lt;- cbind(longitude, latitude)\n\nAfter combining the latitude and longitude data, the first few rows of this merged dataset are checked to ensure correct formatting. This verification step is essential to confirm the proper alignment and accuracy of the data for further analysis.\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n3.5.3.1 Plotting Queen, Rook, Both Queen and Rook Contiguity Based Neighbours Maps\n\nQueen Contiguity Based Neighbours MapRook Contiguity Based Neighbours MapBoth Queen and Rook Contiguity Based Neighbours Map\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n\n\n\n\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\", main=\"Rook Contiguity\")"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#computing-distance-based-neighbors",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#computing-distance-based-neighbors",
    "title": "2A: Spatial Weights and Application",
    "section": "3.6. Computing Distance Based Neighbors",
    "text": "3.6. Computing Distance Based Neighbors\nIn this part of the exercise, I focus on creating distance-based weight matrices using the dnearneigh() function from the spdep package. This function determines neighboring region points based on Euclidean distance, confined within specified distance bounds (lower d1= and upper d2= bounds) set by the bounds= argument. Additionally, if the coordinates used are unprojected and either specified in the coordinates object x or represented as a two-column matrix with longlat=TRUE, the function calculates great circle distances in kilometers, assuming the WGS84 reference ellipsoid. This approach is crucial for accurately determining spatial relationships based on geographic distance.\n\n3.6.1. Determining the Cut-off Distance\nTo determine the upper limit for the distance band, I follow these steps:\n\nUse knearneigh() function from the spdep package to generate a matrix containing the indices of points that are the k nearest neighbors of each other.\nTransform the object returned by knearneigh() into a neighbors list of class nb. This was achieved by using the knn2nb() function, which converts the knn object into a list of integer vectors, each vector containing the neighbor region number IDs.\nEmploy the nbdists() function from spdep to calculate the lengths of the edges connecting each pair of neighbors. This function returns the lengths in the units of the coordinates if they are projected, or in kilometers if they are not.\nUse the unlist() function to remove the list structure from the object returned by nbdists(), thereby simplifying the data for further analysis. This step was essential for accurately establishing the distance-based relationships between the different regional units.\n\n\n#coords &lt;- coordinates(hunan)\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary above indicates that the maximum distance to the nearest neighbor among the units is 61.79 kilometers. Based on this, I set 61.79 km as the upper threshold for the distance band in my analysis. This decision ensures that every unit in the study is guaranteed to have at least one neighbor within this specified distance range, thus maintaining the integrity and relevance of the spatial relationships in the data.\n\n\n3.6.2. Computing Fixed Distance Weight Matrix\nThe following code chunk uses dnearneigh() function to compute the distance weight matrix.\n\nwm_d62 &lt;- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\n\n\n\n\n\nNote\n\n\n\nThe result reveals that the “Average number of links” is 3.681818. The “Average number of links: 3.681818” in the summary of the wm_d62 object indicates the average number of neighbors each region has within the specified distance range. Specifically, it means that on average, each of the 88 regions in the dataset has about 3.68 neighboring regions (or links) within a distance of up to 62 kilometers. This average is calculated based on the total number of links (or neighbor connections) across all regions, divided by the total number of regions. It provides a measure of how interconnected the regions are within the defined distance threshold.\n\n\nThe following code chunk uses str() to display the content from wm_d62 weight matrix.\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nCombined table() and card() functions of spdep package can also be used to display the structure of the weight matrix.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\n3.6.2.1. Plotting Fixed Distance Weight Matrix\n\nCombined PlotSeparate Plots\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n\n\n\n\n\n\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08, main=\"1st nearest neighbours\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main=\"Distance link\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the spatial data visualization, red lines indicate connections to each region’s nearest neighbor, while black lines represent links to all neighbors within a 62 km cut-off distance. This distinction visually differentiates between immediate and broader spatial relationships among regions.\n\n\n\n\n\n3.6.3. Computing Adaptive Distance Weight Matrix\nOne characteristic of the fixed distance weight matrix is its tendency to reflect higher neighbor counts in densely populated areas, typically urban, and lower counts in sparsely populated areas, usually rural. This occurs because the matrix considers all regions within a fixed distance, resulting in urban areas having more neighbors due to their density. This effect smooths out the neighbor relationships across a larger number of neighbors.\nHowever, to manage the number of neighbors more directly, the approach of k-nearest neighbors can be employed. This method allows for specifying the exact number of neighbors for each region, providing the option to either accept asymmetrical neighbor relationships or enforce symmetry. The choice between these options can significantly influence the analysis, as shown in the following code chunk.\n\nknn6 &lt;- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nSimilarly, we can display the content of the matrix by using str().\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the analysis using the k-nearest neighbors method, it is observed that each county consistently has exactly six neighbors. This uniformity in the number of neighbors for each county is ensured by the method’s design, which sets a fixed number of nearest neighbors (in this case, six) for every region, regardless of their geographical size or population density. This approach guarantees that every county is equally considered in terms of its immediate spatial relationships.\n\n\n\n3.6.3.1. Plotting Distance Based Neighbors\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_a.html#weights-based-on-idw",
    "href": "Hands-on_Ex2/Hands-on_Ex2_a.html#weights-based-on-idw",
    "title": "2A: Spatial Weights and Application",
    "section": "3.7. Weights Based On IDW",
    "text": "3.7. Weights Based On IDW\nThe following code chunk uses nbdists() from the spdep package to compute the distances between areas.\n\ndist &lt;- nbdists(wm_q, coords, longlat = TRUE)\nids &lt;- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n[[7]]\n[1] 0.01708612 0.01473997 0.01150924 0.01872915\n\n[[8]]\n[1] 0.02022144 0.03453056 0.02529256 0.01036340 0.02284457 0.01500600 0.01515314\n\n[[9]]\n[1] 0.02022144 0.01574888 0.02109502 0.01508028 0.02902705 0.01502980\n\n[[10]]\n[1] 0.02281552 0.01387777 0.01538326 0.01346650 0.02100510 0.02631658 0.01874863\n[8] 0.01500046\n\n[[11]]\n[1] 0.01882869 0.02243492 0.02247473\n\n[[12]]\n[1] 0.02779227 0.02419652 0.02333385 0.02986130 0.02335429\n\n[[13]]\n[1] 0.02779227 0.02650020 0.02670323 0.01714243\n\n[[14]]\n[1] 0.01882869 0.01233868 0.02098555\n\n[[15]]\n[1] 0.02650020 0.01233868 0.01096284 0.01562226\n\n[[16]]\n[1] 0.02281552 0.02466962 0.02765018 0.01476814 0.01671430\n\n[[17]]\n[1] 0.01387777 0.02243492 0.02098555 0.01096284 0.02466962 0.01593341 0.01437996\n\n[[18]]\n[1] 0.02039779 0.02032767 0.01481665 0.01473691 0.01459380\n\n[[19]]\n[1] 0.01538326 0.01926323 0.02668415 0.02140253 0.01613589 0.01412874\n\n[[20]]\n[1] 0.01346650 0.02039779 0.01926323 0.01723025 0.02153130 0.01469240 0.02327034\n\n[[21]]\n[1] 0.02668415 0.01723025 0.01766299 0.02644986 0.02163800\n\n[[22]]\n[1] 0.02100510 0.02765018 0.02032767 0.02153130 0.01489296\n\n[[23]]\n[1] 0.01481665 0.01469240 0.01401432 0.02246233 0.01880425 0.01530458 0.01849605\n\n[[24]]\n[1] 0.02354598 0.01837201 0.02607264 0.01220154 0.02514180\n\n[[25]]\n[1] 0.02354598 0.02188032 0.01577283 0.01949232 0.02947957\n\n[[26]]\n[1] 0.02155798 0.01745522 0.02212108 0.02220532\n\n[[27]]\n[1] 0.02155798 0.02490625 0.01562326\n\n[[28]]\n[1] 0.01837201 0.02188032 0.02229549 0.03076171 0.02039506\n\n[[29]]\n[1] 0.02490625 0.01686587 0.01395022\n\n[[30]]\n[1] 0.02090587\n\n[[31]]\n[1] 0.02607264 0.01577283 0.01219005 0.01724850 0.01229012 0.01609781 0.01139438\n[8] 0.01150130\n\n[[32]]\n[1] 0.01220154 0.01219005 0.01712515 0.01340413 0.01280928 0.01198216 0.01053374\n[8] 0.01065655\n\n[[33]]\n[1] 0.01949232 0.01745522 0.02229549 0.02090587 0.01979045\n\n[[34]]\n[1] 0.03113041 0.03589551 0.02882915\n\n[[35]]\n[1] 0.01766299 0.02185795 0.02616766 0.02111721 0.02108253 0.01509020\n\n[[36]]\n[1] 0.01724850 0.03113041 0.01571707 0.01860991 0.02073549 0.01680129\n\n[[37]]\n[1] 0.01686587 0.02234793 0.01510990 0.01550676\n\n[[38]]\n[1] 0.01401432 0.02407426 0.02276151 0.01719415\n\n[[39]]\n[1] 0.01229012 0.02172543 0.01711924 0.02629732 0.01896385\n\n[[40]]\n[1] 0.01609781 0.01571707 0.02172543 0.01506473 0.01987922 0.01894207\n\n[[41]]\n[1] 0.02246233 0.02185795 0.02205991 0.01912542 0.01601083 0.01742892\n\n[[42]]\n[1] 0.02212108 0.01562326 0.01395022 0.02234793 0.01711924 0.01836831 0.01683518\n\n[[43]]\n[1] 0.01510990 0.02629732 0.01506473 0.01836831 0.03112027 0.01530782\n\n[[44]]\n[1] 0.01550676 0.02407426 0.03112027 0.01486508\n\n[[45]]\n[1] 0.03589551 0.01860991 0.01987922 0.02205991 0.02107101 0.01982700\n\n[[46]]\n[1] 0.03453056 0.04033752 0.02689769\n\n[[47]]\n[1] 0.02529256 0.02616766 0.04033752 0.01949145 0.02181458\n\n[[48]]\n[1] 0.02313819 0.03370576 0.02289485 0.01630057 0.01818085\n\n[[49]]\n[1] 0.03076171 0.02138091 0.02394529 0.01990000\n\n[[50]]\n[1] 0.01712515 0.02313819 0.02551427 0.02051530 0.02187179\n\n[[51]]\n[1] 0.03370576 0.02138091 0.02873854\n\n[[52]]\n[1] 0.02289485 0.02394529 0.02551427 0.02873854 0.03516672\n\n[[53]]\n[1] 0.01630057 0.01979945 0.01253977\n\n[[54]]\n[1] 0.02514180 0.02039506 0.01340413 0.01990000 0.02051530 0.03516672\n\n[[55]]\n[1] 0.01280928 0.01818085 0.02187179 0.01979945 0.01882298\n\n[[56]]\n[1] 0.01036340 0.01139438 0.01198216 0.02073549 0.01214479 0.01362855 0.01341697\n\n[[57]]\n[1] 0.028079221 0.017643082 0.031423501 0.029114131 0.013520292 0.009903702\n\n[[58]]\n[1] 0.01925924 0.03142350 0.02722997 0.01434859 0.01567192\n\n[[59]]\n[1] 0.01696711 0.01265572 0.01667105 0.01785036\n\n[[60]]\n[1] 0.02419652 0.02670323 0.01696711 0.02343040\n\n[[61]]\n[1] 0.02333385 0.01265572 0.02343040 0.02514093 0.02790764 0.01219751 0.02362452\n\n[[62]]\n[1] 0.02514093 0.02002219 0.02110260\n\n[[63]]\n[1] 0.02986130 0.02790764 0.01407043 0.01805987\n\n[[64]]\n[1] 0.02911413 0.01689892\n\n[[65]]\n[1] 0.02471705\n\n[[66]]\n[1] 0.01574888 0.01726461 0.03068853 0.01954805 0.01810569\n\n[[67]]\n[1] 0.01708612 0.01726461 0.01349843 0.01361172\n\n[[68]]\n[1] 0.02109502 0.02722997 0.03068853 0.01406357 0.01546511\n\n[[69]]\n[1] 0.02174813 0.01645838 0.01419926\n\n[[70]]\n[1] 0.02631658 0.01963168 0.02278487\n\n[[71]]\n[1] 0.01473997 0.01838483 0.03197403\n\n[[72]]\n[1] 0.01874863 0.02247473 0.01476814 0.01593341 0.01963168\n\n[[73]]\n[1] 0.01500046 0.02140253 0.02278487 0.01838483 0.01652709\n\n[[74]]\n[1] 0.01150924 0.01613589 0.03197403 0.01652709 0.01342099 0.02864567\n\n[[75]]\n[1] 0.011883901 0.010533736 0.012539774 0.018822977 0.016458383 0.008217581\n\n[[76]]\n[1] 0.01352029 0.01434859 0.01689892 0.02471705 0.01954805 0.01349843 0.01406357\n\n[[77]]\n[1] 0.014736909 0.018804247 0.022761507 0.012197506 0.020022195 0.014070428\n[7] 0.008440896\n\n[[78]]\n[1] 0.02323898 0.02284457 0.01508028 0.01214479 0.01567192 0.01546511 0.01140779\n\n[[79]]\n[1] 0.01530458 0.01719415 0.01894207 0.01912542 0.01530782 0.01486508 0.02107101\n\n[[80]]\n[1] 0.01500600 0.02882915 0.02111721 0.01680129 0.01601083 0.01982700 0.01949145\n[8] 0.01362855\n\n[[81]]\n[1] 0.02947957 0.02220532 0.01150130 0.01979045 0.01896385 0.01683518\n\n[[82]]\n[1] 0.02327034 0.02644986 0.01849605 0.02108253 0.01742892\n\n[[83]]\n[1] 0.023354289 0.017142433 0.015622258 0.016714303 0.014379961 0.014593799\n[7] 0.014892965 0.018059871 0.008440896\n\n[[84]]\n[1] 0.01872915 0.02902705 0.01810569 0.01361172 0.01342099 0.01297994\n\n[[85]]\n [1] 0.011451133 0.017193502 0.013957649 0.016183544 0.009810297 0.010656545\n [7] 0.013416965 0.009903702 0.014199260 0.008217581 0.011407794\n\n[[86]]\n[1] 0.01515314 0.01502980 0.01412874 0.02163800 0.01509020 0.02689769 0.02181458\n[8] 0.02864567 0.01297994\n\n[[87]]\n[1] 0.01667105 0.02362452 0.02110260 0.02058034\n\n[[88]]\n[1] 0.01785036 0.02058034\n\n\n\n3.7.1. Row-standaundefinedrdized Weights Matrix\nNext in the process, I assign weights to each neighboring polygon. In this scenario, every neighboring polygon is given an equal weight, designated as style “W”. This is achieved by assigning the fraction 1 divided by the number of neighbors to each neighboring county and then summing up the weighted values. This approach, while straightforward and intuitive for summarizing neighbor values, does have a limitation. Specifically, polygons at the edges of the study area, having fewer neighbors, might result in their lagged values being over- or under-estimated, which could skew the understanding of spatial autocorrelation in the data. For the purposes of this exercise, I use the style “W” for its simplicity, but it is worth noting that there are other, more robust options available, like style “B”.\n\nrswm_q &lt;- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nI use the zero.policy=TRUE option in spdep package, which allows handling regions without neighbors. Caution is needed with this option to avoid overlooking missing neighbors, as setting zero.policy=FALSE would result in an error for such cases. To examine the weights of the first polygon’s neighbors, I use a specific command to observe how these weights were allocated.\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n\nEach neighbor is assigned a weight of 0.125. This implies that in the calculation of average neighboring income values, the income of each neighbor is multiplied by 0.2 and then summed up. This approach of assigning equal weights ensures a uniform influence of each neighbor in the overall computation.\nAdditionally, I apply a similar method to create a row-standardized distance weight matrix. For this, I utilize a specific R code chunk, to standardize the weights based on distance, ensuring that the influence of each neighbor is adjusted according to their proximity. This technique is particularly useful in spatial analyses where distance plays a crucial role in determining the relationships between different areas.\n\nrswm_ids &lt;- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/data/geospatial/MPSZ-2019.html",
    "href": "In-class Ex/In-class_Ex1/data/geospatial/MPSZ-2019.html",
    "title": "ISSS624",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1 files/about.html",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1 files/about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1 files/index.html",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1 files/index.html",
    "title": "In-class_Ex1",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1.html",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1.html",
    "title": "Urban Mobility Analysis",
    "section": "",
    "text": "Urban Mobility Analysis by using passenger volume by origin-destination bus stops."
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1.html#overview",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1.html#overview",
    "title": "Urban Mobility Analysis",
    "section": "",
    "text": "Urban Mobility Analysis by using passenger volume by origin-destination bus stops."
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1.html#getting-started",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1.html#getting-started",
    "title": "Urban Mobility Analysis",
    "section": "2. Getting Started",
    "text": "2. Getting Started\nThe code chunk below loads the following packages:\n\ntmap: for thematic mapping\nsf: for geospatial data handling\ntidyverse: for non-spatial data handling\n\n\npacman::p_load(sf, tmap, tidyverse)\n\nThe data used for this analysis includes:\n\nSubzone Boundary Data from the Master Plan 2019 (last updated Dec 2019) from data.gov.sg.\nBus Stop Location Data (last updated Jul 2023) obtained from LTADataMall.\nPassenger Volume Data for Aug-Oct 2023, focusing on origin and destination bus stops, also retrieved from LTADataMall."
  },
  {
    "objectID": "In-class Ex/In-class_Ex1/In-class_Ex1.html#preparing-flow-data",
    "href": "In-class Ex/In-class_Ex1/In-class_Ex1.html#preparing-flow-data",
    "title": "Urban Mobility Analysis",
    "section": "3. Preparing Flow Data",
    "text": "3. Preparing Flow Data\n\n3.1. Importing Passenger Volume by Origin-Destination Bus Stops\nFirstly, we will import the Passenger Volume by Origin-Destination Bus Stops data set download from LTADataMall by using `read_csv()` of readr package and name the dataframe as `odbus`.\n\nodbus &lt;- read_csv(\"data/aspatial/origin_destination_bus_202308.csv\")\n\nTo treat the numeric variables `ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` as categorical grouping variables in R, they should be converted to factors. This transformation allows R to recognize and work with them as categorical variables.\n\nodbus$ORIGIN_PT_CODE &lt;- as.factor(odbus$ORIGIN_PT_CODE)\nodbus$DESTINATION_PT_CODE &lt;- as.factor(odbus$DESTINATION_PT_CODE)\n\n\n\n3.2. Extracting Commuting Flow Data\nThe following code chunk extracts data related to commuting patterns on weekdays during the busy morning rush hours (7 am, 8 am, and 9 am).\n\norigtrip_7_9 &lt;- odbus %&gt;%\n  filter(DAY_TYPE == \"WEEKDAY\") %&gt;%\n  filter(TIME_PER_HOUR &gt;= 7 &\n           TIME_PER_HOUR &lt;= 9) %&gt;%\n  group_by(ORIGIN_PT_CODE) %&gt;%\n  summarise(TRIPS = sum(TOTAL_TRIPS))\n\n\n\n3.3. Importing Geospatial Data\nThe following code chunk uses `st_read()` function from the sf package to import `BusStop` shapefile into R dataframe named `BusStop`. It is configured with the svy21 projected coordinate system, with a `crs` setting of 3414.\n\nbusstop &lt;- st_read(dsn = \"data/geospatial\",\n                   layer = \"BusStop\") %&gt;%\n  st_transform(crs = 3414)\n\n\n\n3.4. Importing Planning Subzone Data\nThe following code chunk uses `st_read()` function from the sf package to import `MPSZ-2019` shapefile into R dataframe named `mpsz`. To enable the combined use of `mpsz` with `BusStop`, `mpsz` is configured with the svy21 projected coordinate system, with a `crs` setting of 3414.\n\nmpsz &lt;- st_read(dsn = \"data/geospatial\",\n                   layer = \"MPSZ-2019\") %&gt;%\n  st_transform(crs = 3414)\n\nReading layer `MPSZ-2019' from data source \n  `D:\\scwsu\\ISSS624\\In-class Ex\\In-class_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n\nmpsz\n\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n                 SUBZONE_N SUBZONE_C       PLN_AREA_N PLN_AREA_C       REGION_N\n1              MARINA EAST    MESZ01      MARINA EAST         ME CENTRAL REGION\n2         INSTITUTION HILL    RVSZ05     RIVER VALLEY         RV CENTRAL REGION\n3           ROBERTSON QUAY    SRSZ01  SINGAPORE RIVER         SR CENTRAL REGION\n4  JURONG ISLAND AND BUKOM    WISZ01  WESTERN ISLANDS         WI    WEST REGION\n5             FORT CANNING    MUSZ02           MUSEUM         MU CENTRAL REGION\n6         MARINA EAST (MP)    MPSZ05    MARINE PARADE         MP CENTRAL REGION\n7                   SUDONG    WISZ03  WESTERN ISLANDS         WI    WEST REGION\n8                  SEMAKAU    WISZ02  WESTERN ISLANDS         WI    WEST REGION\n9           SOUTHERN GROUP    SISZ02 SOUTHERN ISLANDS         SI CENTRAL REGION\n10                 SENTOSA    SISZ01 SOUTHERN ISLANDS         SI CENTRAL REGION\n   REGION_C                       geometry\n1        CR MULTIPOLYGON (((33222.98 29...\n2        CR MULTIPOLYGON (((28481.45 30...\n3        CR MULTIPOLYGON (((28087.34 30...\n4        WR MULTIPOLYGON (((14557.7 304...\n5        CR MULTIPOLYGON (((29542.53 31...\n6        CR MULTIPOLYGON (((35279.55 30...\n7        WR MULTIPOLYGON (((15772.59 21...\n8        WR MULTIPOLYGON (((19843.41 21...\n9        CR MULTIPOLYGON (((30870.53 22...\n10       CR MULTIPOLYGON (((26879.04 26..."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624",
    "section": "",
    "text": "Welcome to ISSS624 Geospatial Analytics Applications!\nIn this webpage, I am going to share with you my learning journey of geospatial analytics."
  }
]