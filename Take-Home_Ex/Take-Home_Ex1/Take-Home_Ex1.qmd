---
title: "Geospatial Analytics for Public Good"
author: "Su Sandi Cho Win"
date: "25 November 2023"
date-modified: "25 November 2023"
format: html
execute:
  echo: true
  eval: true
  warning: false
editor: visual
---

## 1. Overview

The digital transformation of urban infrastructure, including buses, taxis, mass transit, utilities, and roads, has generated vast datasets that serve as a foundation for tracking movement patterns over space and time. Pervasive technologies like GPS and RFID, widely adopted in vehicles, contribute to this trend. For example, smart cards and GPS devices collect route and ridership data on public buses. These extensive datasets likely contain valuable patterns that offer insights into observed phenomena. By deepening our understanding of human mobility in urban areas can improve urban management and provide vital information for both public and private urban transport providers, enhancing their decision-making and competitiveness.

In practical terms, the utilization of these extensive location-aware datasets has predominantly been confined to rudimentary tracking and mapping using Geographic Information System (GIS) applications. This limitation stems primarily from the conventional GIS's inherent lack of robust capabilities for effectively analyzing and modeling spatial and spatio-temporal data.

### 1.1. Objective

Exploratory Spatial Data Analysis (ESDA) represents a powerful approach with the capacity to tackle intricate societal challenges. Within the scope of this study, the objective is to employ suitable Local Indicators of Spatial Association (GLISA) and Emerging Hot Spot Analysis (EHSA) methodologies. This will enable us to unveil the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.

## 2. Getting Started

The following code chunk installs and loads **sf**, **sfdep**, **tmap**, **tidyverse, knitr, dplyr, hexbin** packages into R environment. [*pacman()*](https://cran.r-project.org/web/packages/pacman/readme/README.html) is a R package management tool.

```{r}
pacman::p_load(sf, sfdep, tmap, tidyverse, plotly, knitr, dplyr, hexbin)
```

## 3. Data Preparation

### 3.1. Data

The datasets used for this study are:

-   Master Plan 2019 Planning Sub-zone Geographic Information Systems (GIS) data set of URA from [data.gov.sg](https://beta.data.gov.sg/),

-   Passenger Volume by Origin Destination Bus Stops from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html),

-   Bus Stop Location dataset from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html)

### 3.2. Importing the Data into R Environment

#### **3.2.1. Importing Geospatial Data into R**

```{r}
busstop <- st_read(dsn = "data/geospatial",
                   layer = "BusStop") %>%
  st_transform(crs = 3414)
glimpse(busstop)
```

import *MPSZ-2019* downloaded from eLearn into RStudio and save it as a sf data frame called `mpsz`.

```{r}
mpsz <- st_read(dsn = "data/geospatial",
                   layer = "MPSZ-2019") %>%
  st_transform(crs = 3414)
```

#### **3.3.2. Importing Attribute Data into R**

Firstly, we will import the *Passenger Volume by Origin Destination Bus Stops* data set downloaded from LTA DataMall by using `read_csv()` of **readr** package.

```{r}
odbus <- read_csv("data/aspatial/origin_destination_bus_202308.csv")
glimpse(odbus)
```

```{r}
# Using tidyverse functions to convert these data values into factor data type.
odbus$ORIGIN_PT_CODE <- as.factor(odbus$ORIGIN_PT_CODE)
odbus$DESTINATION_PT_CODE <- as.factor(odbus$DESTINATION_PT_CODE) 
glimpse(odbus)
```

#### 

#### 3.3.3. **Extracting the study data**

::: panel-tabset
## Weekday Morning Peak 6am to 9am

```{r}
origin6_9 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 6 &
           TIME_PER_HOUR <= 9) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))

kable(head(origin6_9))
```

We will save the output in rds format for future use.

```{r}
write_rds(origin6_9, "data/rds/origin6_9.rds")
```

The follwing code chunk will be used to import the saved origin6_9.rds into R environment.

```{r}
origin6_9 <- read_rds("data/rds/origin6_9.rds")
```

## Weekday Afternoon Peak 5pm to 8pm

```{r}
origin17_20 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 17 &
           TIME_PER_HOUR <= 20) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))

kable(head(origin17_20))
```

We will save the output in rds format for future use.

```{r}
write_rds(origin17_20, "data/rds/origin17_20.rds")
```

The following code chunk will be used to import the saved origin17_20. rds into R environment.

```{r}
origin17_20 <- read_rds("data/rds/origin17_20.rds")
```

## Weekends/Holiday Morning Peak 11am to 2pm

```{r}
origin11_14 <- odbus %>%
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%
  filter(TIME_PER_HOUR >= 11 &
           TIME_PER_HOUR <= 14) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))

kable(head(origin11_14))
```

We will save the output in rds format for future use.

```{r}
write_rds(origin11_14, "data/rds/origin11_14.rds")
```

The following code chunk will be used to import the saved origin11_14.rds into R environment.

```{r}
origin11_14 <- read_rds("data/rds/origin11_14.rds")
```

## Weekends/Holiday Evening Peak 4pm to 7pm

```{r}
origin16_19 <- odbus %>%
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%
  filter(TIME_PER_HOUR >= 16 &
           TIME_PER_HOUR <= 19) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))

kable(head(origin16_19))
```

We will save the output in rds format for future use.

```{r}
write_rds(origin16_19, "data/rds/origin16_19.rds")
```

The following code chunk will be used to import the saved origin16_19.rds into R environment.

```{r}
origin16_19 <- read_rds("data/rds/origin16_19.rds")
```
:::

### **3.4. Data Wrangling - Geospatial Data**

::: panel-tabset
## Weekday Morning Peak 6am to 9am

```{r}
origin6_9_busstop <- left_join(busstop, origin6_9,
            by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))
origin6_9_busstop
```

```{r}
duplicate <- origin6_9_busstop %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```

## Weekday Afternoon Peak 5pm to 8pm

```{r}
origin17_20_busstop <- left_join(busstop, origin17_20,
            by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))
origin17_20_busstop
```

```{r}
duplicate <- origin17_20_busstop %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```

## Weekends/Holiday Morning Peak 11am to 2pm

```{r}
origin11_14_busstop <- left_join(busstop, origin11_14,
            by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))
origin11_14_busstop
```

## Weekends/Holiday Evening Peak 4pm to 7pm

```{r}
origin16_19_busstop <- left_join(busstop, origin16_19,
            by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))
origin16_19_busstop
```
:::

3.5. Visualizing

::: panel-tabset
## Weekday Morning Peak 6am to 9am

```{r}
area_honeycomb_grid_6_9 <- st_make_grid(origin6_9_busstop, c(500), what = "polygon", square = FALSE)

# To sf and add grid ID
honeycomb_grid_sf_6_9 <- st_sf(area_honeycomb_grid_6_9) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid_6_9)))

# Perform spatial intersection to count points within each hexagon
point_counts_6_9 <- st_intersection(honeycomb_grid_sf_6_9, origin6_9_busstop) %>%
  group_by(grid_id) %>%
  summarize(TOT_TRIPS = sum(TRIPS, na.rm = TRUE))  # Replace 'TRIPS' with your column name

# Merge the point counts back into the honeycomb grid
honeycomb_grid_sf_6_9 <- honeycomb_grid_sf_6_9 %>%
  st_join(point_counts_6_9, by = "grid_id")

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count_6_9 <- filter(honeycomb_grid_sf_6_9, TOT_TRIPS > 0)
```

```{r}
tmap_mode("view")

map_honeycomb_6_9 <- tm_shape(honeycomb_count_6_9) +
  tm_fill(
    col = "TOT_TRIPS",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of trips: " = "TOT_TRIPS"
    ),
    popup.format = list(
      TOT_TRIPS = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

map_honeycomb_6_9
```

## Weekday Afternoon Peak 5pm to 8pm

```{r}
area_honeycomb_grid_17_20 <- st_make_grid(origin17_20_busstop, c(500), what = "polygon", square = FALSE)

# To sf and add grid ID
honeycomb_grid_sf_17_20 <- st_sf(area_honeycomb_grid_17_20) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid_17_20)))

# Perform spatial intersection to count points within each hexagon
point_counts_17_20 <- st_intersection(honeycomb_grid_sf_17_20, origin17_20_busstop) %>%
  group_by(grid_id) %>%
  summarize(TOT_TRIPS = sum(TRIPS, na.rm = TRUE))  # Replace 'TRIPS' with your column name

# Merge the point counts back into the honeycomb grid
honeycomb_grid_sf_17_20 <- honeycomb_grid_sf_17_20 %>%
  st_join(point_counts_17_20, by = "grid_id")

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count_17_20 <- filter(honeycomb_grid_sf_17_20, TOT_TRIPS > 0)
```

```{r}
tmap_mode("view")

map_honeycomb_17_20 <- tm_shape(honeycomb_count_17_20) +
  tm_fill(
    col = "TOT_TRIPS",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of trips: " = "TOT_TRIPS"
    ),
    popup.format = list(
      TOT_TRIPS = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

map_honeycomb_17_20
```

## Weekends/Holiday Morning Peak 11am to 2pm

```{r}
area_honeycomb_grid_11_14 <- st_make_grid(origin11_14_busstop, c(500), what = "polygon", square = FALSE)

# To sf and add grid ID
honeycomb_grid_sf_11_14 <- st_sf(area_honeycomb_grid_11_14) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid_11_14)))

# Perform spatial intersection to count points within each hexagon
point_counts_11_14 <- st_intersection(honeycomb_grid_sf_11_14, origin11_14_busstop) %>%
  group_by(grid_id) %>%
  summarize(TOT_TRIPS = sum(TRIPS, na.rm = TRUE))  # Replace 'TRIPS' with your column name

# Merge the point counts back into the honeycomb grid
honeycomb_grid_sf_11_14 <- honeycomb_grid_sf_11_14 %>%
  st_join(point_counts_11_14, by = "grid_id")

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count_11_14 <- filter(honeycomb_grid_sf_11_14, TOT_TRIPS > 0)
```

```{r}
tmap_mode("view")

tm_shape(honeycomb_count_11_14) +
  tm_fill(
    col = "TOT_TRIPS",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of trips: " = "TOT_TRIPS"
    ),
    popup.format = list(
      TOT_TRIPS = list(format = "f", digits = 0)
    )
  ) +
  tm_grid(alpha =0.2) +
  tm_borders(col = "grey40", lwd = 0.7)

#map_honeycomb_11_14
```

## Weekends/Holiday Evening Peak 4pm to 7pm

```{r}
area_honeycomb_grid_16_19 <- st_make_grid(origin16_19_busstop, c(500), what = "polygon", square = FALSE)

# To sf and add grid ID
honeycomb_grid_sf_16_19 <- st_sf(area_honeycomb_grid_16_19) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid_16_19)))

# Perform spatial intersection to count points within each hexagon
point_counts_16_19 <- st_intersection(honeycomb_grid_sf_16_19, origin16_19_busstop) %>%
  group_by(grid_id) %>%
  summarize(TOT_TRIPS = sum(TRIPS, na.rm = TRUE))  # Replace 'TRIPS' with your column name

# Merge the point counts back into the honeycomb grid
honeycomb_grid_sf_16_19 <- honeycomb_grid_sf_16_19 %>%
  st_join(point_counts_16_19, by = "grid_id")

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count_16_19 <- filter(honeycomb_grid_sf_16_19, TOT_TRIPS > 0)
```

```{r}
tmap_mode("view")

map_honeycomb_16_19 <- tm_shape(honeycomb_count_16_19) +
  tm_fill(
    col = "TOT_TRIPS",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of trips: " = "TOT_TRIPS"
    ),
    popup.format = list(
      TOT_TRIPS = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

map_honeycomb_16_19
```
:::

## 4. Exploratory Data Analysis

## 5. Exploratory Spatial Data Analysis

### 5.1. **Global Spatial Autocorrelation**

#### 5.1.1. **Spatial Weights Matrix**

#### 5.1.2. **Contiguity-based Spatial Weights**

#### 5.1.2.1. **Contiguity-based (Queen) Spatial Weight Contiguity**

#### 5.1.2.2. **Contiguity-based (Rook) Spatial Weight Contiguity**

#### 5.1.3. **Distance-based Contiguity Weight Matrix**

#### 5.1.3.1. **Fixed Distance Weight Matrix**

#### 5.1.3.2. **Adaptive Distance-based Weight Matrix**

#### 5.1.4. **Which spatial weight matrix to use?**

#### 5.1.5. **Row-Standardised Weights Matrix**

#### 5.1.6. **Computing Global Spatial Autocorrelation Statistics**

#### 5.1.6.1. **Moran's I**

#### 5.1.6.2. **Geary's C**

#### 5.1.7. **Spatial Correlogram**

#### 5.1.7.1. **Moran's I Correlogram**

#### 5.1.7.2. **Geary's C Correlogram**

#### 5.2. **Local Spatial Autocorrelation Statistics**

#### 5.2.1. **Cluster and Outlier Analysis**

#### 5.2.1.1. **Local Moran's I**

#### 5.2.1.2. **Anselin's Moran Scatterplot**

#### 5.2.1.3. **LISA Cluster Maps**

#### 5.2.1.4. **Interpretation of Results**

#### 5.2.2. **Hot Spot Area Analysis**

#### 5.2.2.1. **Getis and Ord's G-Statistics**

#### 5.2.2.2. **Interpretation of Results**

## 6. Conclusion

### 6.1. Future Work
